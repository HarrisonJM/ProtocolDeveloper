.TH "cFunctions::cNetComm" 3 "Wed Apr 3 2019" "Version 0.1" "Protocol Developer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cFunctions::cNetComm \- \fBcNetComm\fP Header file  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cNetComm\&.h>\fP
.PP
Inherits \fBcFunctions::I_cNetComm\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcNetComm\fP ()=default"
.br
.RI "constructor "
.ti -1c
.RI "\fB~cNetComm\fP ()=default"
.br
.RI "destructor "
.ti -1c
.RI "ssize_t \fBsendTo\fP (int sockfd, const void *buf, size_t len, int flags) override"
.br
.RI "man 2 send "
.ti -1c
.RI "ssize_t \fBrecvFrom\fP (int sockfd, void *buf, size_t len, int flags) override"
.br
.RI "man 2 recv "
.ti -1c
.RI "int \fBcloseConnection\fP (int fd) override"
.br
.RI "man 2 close "
.ti -1c
.RI "int \fBgetaddressinfo\fP (const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res) override"
.br
.RI "man 3 getaddrinfo "
.ti -1c
.RI "void \fBfreeaddressinfo\fP (struct addrinfo *res) override"
.br
.RI "man 3 freeadrinfo "
.ti -1c
.RI "int \fBcreateSocket\fP (int domain, int type, int protocol) override"
.br
.RI "man 2 socket "
.ti -1c
.RI "int \fBconnectToRemote\fP (int sockfd, const struct sockaddr *addr, socklen_t addrlen) override"
.br
.RI "man 2 remote "
.in -1c
.SH "Detailed Description"
.PP 
\fBcNetComm\fP Header file 
.PP
Definition at line 19 of file cNetComm\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "int cFunctions::cNetComm::closeConnection (int fd)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 2 close Wrapper for C function close()
.PP
\fBParameters:\fP
.RS 4
\fIfd\fP The File descriptor for the socket we wish to close 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, else -1 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 57 of file cNetComm\&.cpp\&.
.SS "int cFunctions::cNetComm::connectToRemote (int sockfd, const struct sockaddr * addr, socklen_t addrlen)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 2 remote Wrapper for C function connect()
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP The socket file descriptor for us to communicate on 
.br
\fIaddr\fP 
.br
\fIaddrlen\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 109 of file cNetComm\&.cpp\&.
.SS "int cFunctions::cNetComm::createSocket (int domain, int type, int protocol)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 2 socket Wrapper for C function socket()
.PP
\fBParameters:\fP
.RS 4
\fIdomain\fP The ai_family 
.br
\fItype\fP The ai_socktype 
.br
\fIprotocol\fP ai_protocol 
.RE
.PP
\fBReturns:\fP
.RS 4
A new socket file descriptor for us to use to communicate 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 94 of file cNetComm\&.cpp\&.
.SS "void cFunctions::cNetComm::freeaddressinfo (struct addrinfo * res)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 3 freeadrinfo Wrapper for C function freeaddrinfo\&.
.PP
\fBParameters:\fP
.RS 4
\fIres\fP The linked list result we wish to free 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 83 of file cNetComm\&.cpp\&.
.SS "int cFunctions::cNetComm::getaddressinfo (const char * node, const char * service, const struct addrinfo * hints, struct addrinfo ** res)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 3 getaddrinfo Wrapper for C function getaddrinfo\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP A pointer to the address of the remote we wish to connect to 
.br
\fIservice\fP The port we wish to connect on 
.br
\fIhints\fP Any hints we want to supply to get a more specific address range 
.br
\fIres\fP The resultant struct of addresses as a linked list 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or a non-zero error code: getaddrinfo(3) 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 69 of file cNetComm\&.cpp\&.
.SS "ssize_t cFunctions::cNetComm::recvFrom (int sockfd, void * buf, size_t len, int flags)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 2 recv Wrapper for C function recv()
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP The File Descriptor of where we wish to send the packet 
.br
\fIbuf\fP The Packet itself 
.br
\fIlen\fP The size of the packet 
.br
\fIflags\fP Additional information 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes sent, -1 on error 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 42 of file cNetComm\&.cpp\&.
.SS "ssize_t cFunctions::cNetComm::sendTo (int sockfd, const void * buf, size_t len, int flags)\fC [override]\fP, \fC [virtual]\fP"

.PP
man 2 send Wrapper for C function send()
.PP
\fBParameters:\fP
.RS 4
\fIsockfd\fP The File Descriptor of where we wish to send the packet 
.br
\fIbuf\fP The Packet itself 
.br
\fIlen\fP The size of the packet 
.br
\fIflags\fP Additional information 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes sent, -1 on error 
.RE
.PP

.PP
Implements \fBcFunctions::I_cNetComm\fP\&.
.PP
Definition at line 24 of file cNetComm\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Protocol Developer from the source code\&.
